<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>ExtendedMessageSource.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Acme-Planner (Run) (2 Jun 2021 12:07:42)</a> &gt; <a href="../../index.html" class="el_group">Acme-Planner</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">acme.framework.patches</a> &gt; <span class="el_source">ExtendedMessageSource.java</span></div><h1>ExtendedMessageSource.java</h1><pre class="source lang-java linenums">/*
 * ExtendedMessageSource.java
 *
 * Copyright (C) 2012-2021 Rafael Corchuelo.
 *
 * In keeping with the traditional purpose of furthering education and research, it is
 * the policy of the copyright owner to permit non-commercial use and redistribution of
 * this software. It has been tested carefully, but it is not guaranteed for any particular
 * purposes. The copyright owner does not offer any warranties or representations, nor do
 * they accept any liabilities with respect to them.
 */

// HINT: The original source was patched by RC so that it accepts ANT-like patterns. This
// HINT+ saves a lot of work and mistakes when specifying the i18n message bundles. The
// HINT+ default extension of the bundles was changed to &quot;.messages&quot;, which seems more
// HINT+ intuitive than the generic &quot;.properties&quot; extension. The &quot;.xml&quot; extension is not
// HINT+ supported at all. The changes are marked with RC+ or RC- blocks in the source code.

package acme.framework.patches;

/*
 * Copyright 2002-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.text.MessageFormat;
import java.util.ArrayList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.locks.ReentrantLock;

import org.springframework.context.MessageSource;
import org.springframework.context.ResourceLoaderAware;
import org.springframework.context.support.AbstractResourceBasedMessageSource;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.context.support.ResourceBundleMessageSource;
import org.springframework.core.io.DefaultResourceLoader;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.core.io.support.PathMatchingResourcePatternResolver;
import org.springframework.lang.Nullable;
import org.springframework.util.DefaultPropertiesPersister;
import org.springframework.util.PropertiesPersister;
import org.springframework.util.StringUtils;

import acme.framework.helpers.StringHelper;

/**
 * Spring-specific {@link org.springframework.context.MessageSource} implementation
 * that accesses resource bundles using specified basenames, participating in the
 * Spring {@link org.springframework.context.ApplicationContext}'s resource loading.
 *
 * &lt;p&gt;
 * In contrast to the JDK-based {@link ResourceBundleMessageSource}, this class uses
 * {@link java.util.Properties} instances as its custom data structure for messages,
 * loading them via a {@link org.springframework.util.PropertiesPersister} strategy
 * from Spring {@link Resource} handles. This strategy is not only capable of
 * reloading files based on timestamp changes, but also of loading properties files
 * with a specific character encoding. It will detect XML property files as well.
 *
 * &lt;p&gt;
 * Note that the basenames set as {@link #setBasenames &quot;basenames&quot;} property
 * are treated in a slightly different fashion than the &quot;basenames&quot; property of
 * {@link ResourceBundleMessageSource}. It follows the basic ResourceBundle rule of not
 * specifying file extension or language codes, but can refer to any Spring resource
 * location (instead of being restricted to classpath resources). With a &quot;classpath:&quot;
 * prefix, resources can still be loaded from the classpath, but &quot;cacheSeconds&quot; values
 * other than &quot;-1&quot; (caching forever) might not work reliably in this case.
 *
 * &lt;p&gt;
 * For a typical web application, message files could be placed in {@code WEB-INF}:
 * e.g. a &quot;WEB-INF/messages&quot; basename would find a &quot;WEB-INF/messages.properties&quot;,
 * &quot;WEB-INF/messages_en.properties&quot; etc arrangement as well as &quot;WEB-INF/messages.xml&quot;,
 * &quot;WEB-INF/messages_en.xml&quot; etc. Note that message definitions in a &lt;i&gt;previous&lt;/i&gt;
 * resource bundle will override ones in a later bundle, due to sequential lookup.
 *
 * &lt;p&gt;
 * This MessageSource can easily be used outside of an
 * {@link org.springframework.context.ApplicationContext}: it will use a
 * {@link org.springframework.core.io.DefaultResourceLoader} as default,
 * simply getting overridden with the ApplicationContext's resource loader
 * if running in a context. It does not have any other specific dependencies.
 *
 * &lt;p&gt;
 * Thanks to Thomas Achleitner for providing the initial implementation of
 * this message source!
 *
 * @author Juergen Hoeller
 * @see #setCacheSeconds
 * @see #setBasenames
 * @see #setDefaultEncoding
 * @see #setFileEncodings
 * @see #setPropertiesPersister
 * @see #setResourceLoader
 * @see org.springframework.util.DefaultPropertiesPersister
 * @see org.springframework.core.io.DefaultResourceLoader
 * @see ResourceBundleMessageSource
 * @see java.util.ResourceBundle
 */
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">public class ExtendedMessageSource extends AbstractResourceBasedMessageSource implements ResourceLoaderAware {</span>

<span class="fc" id="L120">	protected static final String										PROPERTIES_SUFFIX		= &quot;.messages&quot;;</span>

	// RC-
	// protected static final String										XML_SUFFIX				= &quot;.xml&quot;;
	// RC-

	@Nullable
	protected Properties												fileEncodings;

<span class="fc" id="L129">	protected boolean													concurrentRefresh		= true;</span>

<span class="fc" id="L131">	protected PropertiesPersister										propertiesPersister		= new DefaultPropertiesPersister();</span>

<span class="fc" id="L133">	protected ResourceLoader											resourceLoader			= new DefaultResourceLoader();</span>

	// Cache to hold filename lists per Locale
<span class="fc" id="L136">	protected final ConcurrentMap&lt;String, Map&lt;Locale, List&lt;String&gt;&gt;&gt;	cachedFilenames			= new ConcurrentHashMap&lt;&gt;();</span>

	// Cache to hold already loaded properties per filename
<span class="fc" id="L139">	protected final ConcurrentMap&lt;String, PropertiesHolder&gt;				cachedProperties		= new ConcurrentHashMap&lt;&gt;();</span>

	// Cache to hold already loaded properties per filename
<span class="fc" id="L142">	protected final ConcurrentMap&lt;Locale, PropertiesHolder&gt;				cachedMergedProperties	= new ConcurrentHashMap&lt;&gt;();</span>


	/**
	 * Set per-file charsets to use for parsing properties files.
	 * &lt;p&gt;
	 * Only applies to classic properties files, not to XML files.
	 *
	 * @param fileEncodings
	 *            a Properties with filenames as keys and charset
	 *            names as values. Filenames have to match the basename syntax,
	 *            with optional locale-specific components: e.g. &quot;WEB-INF/messages&quot;
	 *            or &quot;WEB-INF/messages_en&quot;.
	 * @see #setBasenames
	 * @see org.springframework.util.PropertiesPersister#load
	 */
	public void setFileEncodings(final Properties fileEncodings) {
<span class="nc" id="L159">		this.fileEncodings = fileEncodings;</span>
<span class="nc" id="L160">	}</span>

	/**
	 * Specify whether to allow for concurrent refresh behavior, i.e. one thread
	 * locked in a refresh attempt for a specific cached properties file whereas
	 * other threads keep returning the old properties for the time being, until
	 * the refresh attempt has completed.
	 * &lt;p&gt;
	 * Default is &quot;true&quot;: this behavior is new as of Spring Framework 4.1,
	 * minimizing contention between threads. If you prefer the old behavior,
	 * i.e. to fully block on refresh, switch this flag to &quot;false&quot;.
	 *
	 * @since 4.1
	 * @see #setCacheSeconds
	 */
	public void setConcurrentRefresh(final boolean concurrentRefresh) {
<span class="nc" id="L176">		this.concurrentRefresh = concurrentRefresh;</span>
<span class="nc" id="L177">	}</span>

	/**
	 * Set the PropertiesPersister to use for parsing properties files.
	 * &lt;p&gt;
	 * The default is a DefaultPropertiesPersister.
	 *
	 * @see org.springframework.util.DefaultPropertiesPersister
	 */
	public void setPropertiesPersister(@Nullable final PropertiesPersister propertiesPersister) {
<span class="nc bnc" id="L187" title="All 2 branches missed.">		this.propertiesPersister = propertiesPersister != null ? propertiesPersister : new DefaultPropertiesPersister();</span>
<span class="nc" id="L188">	}</span>

	/**
	 * Set the ResourceLoader to use for loading bundle properties files.
	 * &lt;p&gt;
	 * The default is a DefaultResourceLoader. Will get overridden by the
	 * ApplicationContext if running in a context, as it implements the
	 * ResourceLoaderAware interface. Can be manually overridden when
	 * running outside of an ApplicationContext.
	 *
	 * @see org.springframework.core.io.DefaultResourceLoader
	 * @see org.springframework.context.ResourceLoaderAware
	 */
	@Override
	public void setResourceLoader(@Nullable final ResourceLoader resourceLoader) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">		this.resourceLoader = resourceLoader != null ? resourceLoader : new DefaultResourceLoader();</span>
<span class="fc" id="L204">	}</span>

	/**
	 * Resolves the given message code as key in the retrieved bundle files,
	 * returning the value found in the bundle as-is (without MessageFormat parsing).
	 */
	@Override
	protected String resolveCodeWithoutArguments(final String code, final Locale locale) {
<span class="pc bpc" id="L212" title="1 of 2 branches missed.">		if (this.getCacheMillis() &lt; 0) {</span>
<span class="fc" id="L213">			final PropertiesHolder propHolder = this.getMergedProperties(locale);</span>
<span class="fc" id="L214">			final String result = propHolder.getProperty(code);</span>
<span class="fc bfc" id="L215" title="All 2 branches covered.">			if (result != null) {</span>
<span class="fc" id="L216">				return result;</span>
			}
		} else {
<span class="nc bnc" id="L219" title="All 2 branches missed.">			for (final String basename : this.getBasenameSet()) {</span>
<span class="nc" id="L220">				final List&lt;String&gt; filenames = this.calculateAllFilenames(basename, locale);</span>
<span class="nc bnc" id="L221" title="All 2 branches missed.">				for (final String filename : filenames) {</span>
<span class="nc" id="L222">					final PropertiesHolder propHolder = this.getProperties(filename);</span>
<span class="nc" id="L223">					final String result = propHolder.getProperty(code);</span>
<span class="nc bnc" id="L224" title="All 2 branches missed.">					if (result != null) {</span>
<span class="nc" id="L225">						return result;</span>
					}
				}
			}
		}
<span class="fc" id="L230">		return null;</span>
	}

	/**
	 * Resolves the given message code as key in the retrieved bundle files,
	 * using a cached MessageFormat instance per message code.
	 */
	@Override
	@Nullable
	protected MessageFormat resolveCode(final String code, final Locale locale) {
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">		if (this.getCacheMillis() &lt; 0) {</span>
<span class="fc" id="L241">			final PropertiesHolder propHolder = this.getMergedProperties(locale);</span>
<span class="fc" id="L242">			final MessageFormat result = propHolder.getMessageFormat(code, locale);</span>
<span class="fc bfc" id="L243" title="All 2 branches covered.">			if (result != null) {</span>
<span class="fc" id="L244">				return result;</span>
			}
		} else {
<span class="nc bnc" id="L247" title="All 2 branches missed.">			for (final String basename : this.getBasenameSet()) {</span>
<span class="nc" id="L248">				final List&lt;String&gt; filenames = this.calculateAllFilenames(basename, locale);</span>
<span class="nc bnc" id="L249" title="All 2 branches missed.">				for (final String filename : filenames) {</span>
<span class="nc" id="L250">					final PropertiesHolder propHolder = this.getProperties(filename);</span>
<span class="nc" id="L251">					final MessageFormat result = propHolder.getMessageFormat(code, locale);</span>
<span class="nc bnc" id="L252" title="All 2 branches missed.">					if (result != null) {</span>
<span class="nc" id="L253">						return result;</span>
					}
				}
			}
		}
<span class="fc" id="L258">		return null;</span>
	}

	/**
	 * Get a PropertiesHolder that contains the actually visible properties
	 * for a Locale, after merging all specified resource bundles.
	 * Either fetches the holder from the cache or freshly loads it.
	 * &lt;p&gt;
	 * Only used when caching resource bundle contents forever, i.e.
	 * with cacheSeconds &lt; 0. Therefore, merged properties are always
	 * cached forever.
	 */
	protected PropertiesHolder getMergedProperties(final Locale locale) {
<span class="fc" id="L271">		PropertiesHolder mergedHolder = this.cachedMergedProperties.get(locale);</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">		if (mergedHolder != null) {</span>
<span class="fc" id="L273">			return mergedHolder;</span>
		}
<span class="fc" id="L275">		final Properties mergedProps = this.newProperties();</span>
<span class="fc" id="L276">		long latestTimestamp = -1;</span>
<span class="fc" id="L277">		final String[] basenames = StringUtils.toStringArray(this.getBasenameSet());</span>
<span class="fc bfc" id="L278" title="All 2 branches covered.">		for (int i = basenames.length - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L279">			final List&lt;String&gt; filenames = this.calculateAllFilenames(basenames[i], locale);</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">			for (int j = filenames.size() - 1; j &gt;= 0; j--) {</span>
<span class="fc" id="L281">				final String filename = filenames.get(j);</span>
<span class="fc" id="L282">				final PropertiesHolder propHolder = this.getProperties(filename);</span>
<span class="pc bpc" id="L283" title="1 of 2 branches missed.">				if (propHolder.getProperties() != null) {</span>
<span class="fc" id="L284">					mergedProps.putAll(propHolder.getProperties());</span>
<span class="fc bfc" id="L285" title="All 2 branches covered.">					if (propHolder.getFileTimestamp() &gt; latestTimestamp) {</span>
<span class="fc" id="L286">						latestTimestamp = propHolder.getFileTimestamp();</span>
					}
				}
			}
		}
<span class="fc" id="L291">		mergedHolder = new PropertiesHolder(mergedProps, latestTimestamp);</span>
<span class="fc" id="L292">		final PropertiesHolder existing = this.cachedMergedProperties.putIfAbsent(locale, mergedHolder);</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">		if (existing != null) {</span>
<span class="nc" id="L294">			mergedHolder = existing;</span>
		}
<span class="fc" id="L296">		return mergedHolder;</span>
	}

	/**
	 * Calculate all filenames for the given bundle basename and Locale.
	 * Will calculate filenames for the given Locale, the system Locale
	 * (if applicable), and the default file.
	 *
	 * @param basename
	 *            the basename of the bundle
	 * @param locale
	 *            the locale
	 * @return the List of filenames to check
	 * @see #setFallbackToSystemLocale
	 * @see #calculateFilenamesForLocale
	 */
	// RC-
	//	protected List&lt;String&gt; calculateAllFilenames(final String basename, final Locale locale) {
	//		Map&lt;Locale, List&lt;String&gt;&gt; localeMap = this.cachedFilenames.get(basename);
	//		if (localeMap != null) {
	//			List&lt;String&gt; filenames = localeMap.get(locale);
	//			if (filenames != null) {
	//				return filenames;
	//			}
	//		}
	//		List&lt;String&gt; filenames = new ArrayList&lt;&gt;(7);
	//		filenames.addAll(this.calculateFilenamesForLocale(basename, locale));
	//		if (this.isFallbackToSystemLocale() &amp;&amp; !locale.equals(Locale.getDefault())) {
	//			List&lt;String&gt; fallbackFilenames = this.calculateFilenamesForLocale(basename, Locale.getDefault());
	//			for (String fallbackFilename : fallbackFilenames) {
	//				if (!filenames.contains(fallbackFilename)) {
	//					// Entry for fallback locale that isn't already in filenames list.
	//					filenames.add(fallbackFilename);
	//				}
	//			}
	//		}
	//		filenames.add(basename);
	//		if (localeMap == null) {
	//			localeMap = new ConcurrentHashMap&lt;&gt;();
	//			Map&lt;Locale, List&lt;String&gt;&gt; existing = this.cachedFilenames.putIfAbsent(basename, localeMap);
	//			if (existing != null) {
	//				localeMap = existing;
	//			}
	//		}
	//		localeMap.put(locale, filenames);
	//		return filenames;
	//	}
	// RC-

	// RC+
	@SuppressWarnings(&quot;deprecation&quot;)
	protected List&lt;String&gt; calculateAllFilenames(final String basename, final Locale locale) {
		List&lt;String&gt; result;
		Map&lt;Locale, List&lt;String&gt;&gt; localeMap, existing;
		Locale defaultLocale;
		String path;
		List&lt;String&gt; defaults;

<span class="fc" id="L354">		result = null;</span>
<span class="fc" id="L355">		localeMap = this.cachedFilenames.get(basename);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">		if (localeMap != null) {</span>
<span class="fc" id="L357">			result = localeMap.get(locale);</span>
		}

<span class="pc bpc" id="L360" title="1 of 2 branches missed.">		if (result == null) {</span>
<span class="fc" id="L361">			defaultLocale = Locale.getDefault();</span>

<span class="fc" id="L363">			path = basename;</span>
<span class="pc bpc" id="L364" title="1 of 2 branches missed.">			if (path.endsWith(ExtendedMessageSource.PROPERTIES_SUFFIX)) {</span>
<span class="fc" id="L365">				path = path.replace(ExtendedMessageSource.PROPERTIES_SUFFIX, &quot;&quot;);</span>
			}

<span class="fc" id="L368">			result = this.computeFilenames(path, locale);</span>
<span class="pc bpc" id="L369" title="1 of 4 branches missed.">			if (this.isFallbackToSystemLocale() &amp;&amp; !locale.equals(defaultLocale)) {</span>
<span class="fc" id="L370">				defaults = this.computeFilenames(path, defaultLocale);</span>
<span class="fc" id="L371">				result.addAll(defaults);</span>
			}

<span class="fc bfc" id="L374" title="All 2 branches covered.">			if (localeMap == null) {</span>
<span class="fc" id="L375">				localeMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L376">				existing = this.cachedFilenames.putIfAbsent(basename, localeMap);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">				if (existing != null) {</span>
<span class="nc" id="L378">					localeMap = existing;</span>
				}
			}

<span class="fc" id="L382">			localeMap.put(locale, result);</span>
		}

<span class="fc" id="L385">		return result;</span>
	}

	protected List&lt;String&gt; computeFilenames(final String path, final Locale locale) {
		List&lt;String&gt; result;
		List&lt;String&gt; suffixes;
		String localisedPath;

<span class="fc" id="L393">		result = new ArrayList&lt;String&gt;();</span>
<span class="fc" id="L394">		suffixes = this.computeSuffixes(locale);</span>
<span class="fc bfc" id="L395" title="All 2 branches covered.">		for (final String suffix : suffixes) {</span>
<span class="fc" id="L396">			localisedPath = String.format(&quot;%s%s&quot;, path, suffix);</span>
<span class="fc" id="L397">			result.add(localisedPath);</span>
		}

<span class="fc" id="L400">		return result;</span>
	}

	protected List&lt;String&gt; computeSuffixes(final Locale locale) {
		List&lt;String&gt; result;
		String language, country, variant;
		StringBuilder builder;

<span class="fc" id="L408">		result = new ArrayList&lt;String&gt;();</span>

<span class="fc" id="L410">		language = locale.getLanguage();</span>
<span class="fc" id="L411">		country = locale.getCountry();</span>
<span class="fc" id="L412">		variant = locale.getVariant();</span>

<span class="fc" id="L414">		builder = new StringBuilder();</span>

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">		if (!language.isEmpty()) {</span>
<span class="fc" id="L417">			builder.append(String.format(&quot;_%s&quot;, language));</span>
<span class="fc" id="L418">			result.add(0, builder.toString());</span>
		}

<span class="pc bpc" id="L421" title="1 of 2 branches missed.">		if (!country.isEmpty()) {</span>
<span class="nc" id="L422">			builder.append(String.format(&quot;_%s&quot;, country));</span>
<span class="nc" id="L423">			result.add(0, builder.toString());</span>
		}

<span class="pc bpc" id="L426" title="1 of 2 branches missed.">		if (!variant.isEmpty()) {</span>
<span class="nc" id="L427">			builder.append(String.format(&quot;_%s&quot;, variant));</span>
<span class="nc" id="L428">			result.add(0, builder.toString());</span>
		}

<span class="fc" id="L431">		return result;</span>
	}
	// RC+

	// RC-
	//	/**
	//	 * Calculate the filenames for the given bundle basename and Locale,
	//	 * appending language code, country code, and variant code.
	//	 * E.g.: basename &quot;messages&quot;, Locale &quot;de_AT_oo&quot; -&gt; &quot;messages_de_AT_OO&quot;,
	//	 * &quot;messages_de_AT&quot;, &quot;messages_de&quot;.
	//	 * &lt;p&gt;
	//	 * Follows the rules defined by {@link java.util.Locale#toString()}.
	//	 *
	//	 * @param basename
	//	 *            the basename of the bundle
	//	 * @param locale
	//	 *            the locale
	//	 * @return the List of filenames to check
	//	 */

	//	protected List&lt;String&gt; calculateFilenamesForLocale(final String basename, final Locale locale) {
	//		List&lt;String&gt; result = new ArrayList&lt;&gt;(3);
	//		String language = locale.getLanguage();
	//		String country = locale.getCountry();
	//		String variant = locale.getVariant();
	//		StringBuilder temp = new StringBuilder(basename);
	//
	//		temp.append('_');
	//		if (language.length() &gt; 0) {
	//			temp.append(language);
	//			result.add(0, temp.toString());
	//		}
	//
	//		temp.append('_');
	//		if (country.length() &gt; 0) {
	//			temp.append(country);
	//			result.add(0, temp.toString());
	//		}
	//
	//		if (variant.length() &gt; 0 &amp;&amp; (language.length() &gt; 0 || country.length() &gt; 0)) {
	//			temp.append('_').append(variant);
	//			result.add(0, temp.toString());
	//		}
	//
	//		return result;
	//	}
	// RC-

	/**
	 * Get a PropertiesHolder for the given filename, either from the
	 * cache or freshly loaded.
	 *
	 * @param filename
	 *            the bundle filename (basename + Locale)
	 * @return the current PropertiesHolder for the bundle
	 */
	protected PropertiesHolder getProperties(final String filename) {
<span class="fc" id="L488">		PropertiesHolder propHolder = this.cachedProperties.get(filename);</span>
<span class="fc" id="L489">		long originalTimestamp = -2;</span>

<span class="fc bfc" id="L491" title="All 2 branches covered.">		if (propHolder != null) {</span>
<span class="fc" id="L492">			originalTimestamp = propHolder.getRefreshTimestamp();</span>
<span class="pc bpc" id="L493" title="2 of 4 branches missed.">			if (originalTimestamp == -1 || originalTimestamp &gt; System.currentTimeMillis() - this.getCacheMillis()) {</span>
				// Up to date
<span class="nc" id="L495">				return propHolder;</span>
			}
		} else {
<span class="fc" id="L498">			propHolder = new PropertiesHolder();</span>
<span class="fc" id="L499">			final PropertiesHolder existingHolder = this.cachedProperties.putIfAbsent(filename, propHolder);</span>
<span class="pc bpc" id="L500" title="1 of 2 branches missed.">			if (existingHolder != null) {</span>
<span class="nc" id="L501">				propHolder = existingHolder;</span>
			}
		}

		// At this point, we need to refresh...
<span class="pc bpc" id="L506" title="2 of 4 branches missed.">		if (this.concurrentRefresh &amp;&amp; propHolder.getRefreshTimestamp() &gt;= 0) {</span>
			// A populated but stale holder -&gt; could keep using it.
<span class="nc bnc" id="L508" title="All 2 branches missed.">			if (!propHolder.refreshLock.tryLock()) {</span>
				// Getting refreshed by another thread already -&gt;
				// let's return the existing properties for the time being.
<span class="nc" id="L511">				return propHolder;</span>
			}
		} else {
<span class="fc" id="L514">			propHolder.refreshLock.lock();</span>
		}
		try {
<span class="fc" id="L517">			final PropertiesHolder existingHolder = this.cachedProperties.get(filename);</span>
<span class="pc bpc" id="L518" title="2 of 4 branches missed.">			if (existingHolder != null &amp;&amp; existingHolder.getRefreshTimestamp() &gt; originalTimestamp) {</span>
<span class="nc" id="L519">				return existingHolder;</span>
			}
<span class="fc" id="L521">			return this.refreshProperties(filename, propHolder);</span>
		} finally {
<span class="fc" id="L523">			propHolder.refreshLock.unlock();</span>
		}
	}


	// RC+
<span class="fc" id="L529">	protected PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver();</span>


	protected PropertiesHolder refreshProperties(final String filename, final PropertiesHolder oldHolder) {
<span class="pc bpc" id="L533" title="2 of 4 branches missed.">		assert !StringHelper.isBlank(filename);</span>
<span class="pc bpc" id="L534" title="2 of 4 branches missed.">		assert oldHolder != null;</span>

		PropertiesHolder result;
		Properties properties;
		long lastModified;
		Resource[] resources;
		String basename, path;
		PropertiesHolder newHolder;

<span class="fc" id="L543">		result = null;</span>
<span class="fc" id="L544">		properties = new Properties();</span>
<span class="fc" id="L545">		lastModified = -1;</span>
		try {
			//basename = String.format(&quot;classpath:%s&quot;, filename +  ExtendedMessageSource.PROPERTIES_SUFFIX);
<span class="fc" id="L548">			basename = filename + ExtendedMessageSource.PROPERTIES_SUFFIX;</span>
			//this.logger.info(&quot;user.dir = &quot; + System.getProperty(&quot;user.dir&quot;));
			//this.logger.info(&quot;basename = &quot; + basename);
<span class="fc" id="L551">			resources = this.resolver.getResources(basename);</span>
<span class="fc bfc" id="L552" title="All 2 branches covered.">			for (final Resource resource : resources) {</span>
<span class="fc" id="L553">				path = resource.getURI().toString().replace(ExtendedMessageSource.PROPERTIES_SUFFIX, &quot;&quot;);</span>
				//this.logger.info(&quot;resource = &quot; + path);
<span class="fc" id="L555">				newHolder = this.originalRefreshProperties(path, oldHolder);</span>
<span class="fc" id="L556">				properties.putAll(newHolder.getProperties());</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">				if (lastModified &lt; resource.lastModified()) {</span>
<span class="fc" id="L558">					lastModified = resource.lastModified();</span>
				}
			}
<span class="fc" id="L561">			result = new PropertiesHolder(properties, lastModified);</span>
<span class="pc" id="L562">		} catch (final IOException oops) {</span>
<span class="nc" id="L563">			throw new RuntimeException(oops);</span>
		}

<span class="pc bpc" id="L566" title="2 of 4 branches missed.">		assert result != null;</span>

<span class="fc" id="L568">		return result;</span>
	}
	// RC+

	/**
	 * Refresh the PropertiesHolder for the given bundle filename.
	 * The holder can be {@code null} if not cached before, or a timed-out cache entry
	 * (potentially getting re-validated against the current last-modified timestamp).
	 *
	 * @param filename
	 *            the bundle filename (basename + Locale)
	 * @param propHolder
	 *            the current PropertiesHolder for the bundle
	 */
	protected PropertiesHolder originalRefreshProperties(final String filename, @Nullable PropertiesHolder propHolder) {
<span class="pc bpc" id="L583" title="1 of 2 branches missed.">		final long refreshTimestamp = this.getCacheMillis() &lt; 0 ? -1 : System.currentTimeMillis();</span>
<span class="fc" id="L584">		final Resource resource = this.resourceLoader.getResource(filename + ExtendedMessageSource.PROPERTIES_SUFFIX);</span>

		// RC-
		//		if (!resource.exists()) {
		//			resource = this.resourceLoader.getResource(filename + ExtendedMessageSource.XML_SUFFIX);
		//		}
		// RC-

<span class="pc bpc" id="L592" title="1 of 2 branches missed.">		if (resource.exists()) {</span>
<span class="fc" id="L593">			long fileTimestamp = -1;</span>
<span class="pc bpc" id="L594" title="1 of 2 branches missed.">			if (this.getCacheMillis() &gt;= 0) {</span>
				// Last-modified timestamp of file will just be read if caching with timeout.
				try {
<span class="nc" id="L597">					fileTimestamp = resource.lastModified();</span>
<span class="nc bnc" id="L598" title="All 4 branches missed.">					if (propHolder != null &amp;&amp; propHolder.getFileTimestamp() == fileTimestamp) {</span>
<span class="nc bnc" id="L599" title="All 2 branches missed.">						if (this.logger.isDebugEnabled()) {</span>
<span class="nc" id="L600">							this.logger.debug(&quot;Re-caching properties for filename [&quot; + filename + &quot;] - file hasn't been modified&quot;);</span>
						}
<span class="nc" id="L602">						propHolder.setRefreshTimestamp(refreshTimestamp);</span>
<span class="nc" id="L603">						return propHolder;</span>
					}
<span class="nc" id="L605">				} catch (final IOException ex) {</span>
					// Probably a class path resource: cache it forever.
<span class="nc bnc" id="L607" title="All 2 branches missed.">					if (this.logger.isDebugEnabled()) {</span>
<span class="nc" id="L608">						this.logger.debug(resource + &quot; could not be resolved in the file system - assuming that it hasn't changed&quot;, ex);</span>
					}
<span class="nc" id="L610">					fileTimestamp = -1;</span>
				}
			}
			try {
<span class="fc" id="L614">				final Properties props = this.loadProperties(resource, filename);</span>
<span class="fc" id="L615">				propHolder = new PropertiesHolder(props, fileTimestamp);</span>
<span class="pc" id="L616">			} catch (final IOException ex) {</span>
<span class="nc bnc" id="L617" title="All 2 branches missed.">				if (this.logger.isWarnEnabled()) {</span>
<span class="nc" id="L618">					this.logger.warn(&quot;Could not parse properties file [&quot; + resource.getFilename() + &quot;]&quot;, ex);</span>
				}
				// Empty holder representing &quot;not valid&quot;.
<span class="nc" id="L621">				propHolder = new PropertiesHolder();</span>
			}
<span class="nc" id="L623">		}</span>
		else {
			// Resource does not exist.
<span class="nc bnc" id="L626" title="All 2 branches missed.">			if (this.logger.isDebugEnabled()) {</span>
<span class="nc" id="L627">				this.logger.debug(&quot;No properties file found for [&quot; + filename + &quot;] - neither plain properties nor XML&quot;);</span>
			}
			// Empty holder representing &quot;not found&quot;.
<span class="nc" id="L630">			propHolder = new PropertiesHolder();</span>
		}

<span class="fc" id="L633">		propHolder.setRefreshTimestamp(refreshTimestamp);</span>
<span class="fc" id="L634">		this.cachedProperties.put(filename, propHolder);</span>
<span class="fc" id="L635">		return propHolder;</span>
	}

	/**
	 * Load the properties from the given resource.
	 *
	 * @param resource
	 *            the resource to load from
	 * @param filename
	 *            the original bundle filename (basename + Locale)
	 * @return the populated Properties instance
	 * @throws IOException
	 *             if properties loading failed
	 */
	protected Properties loadProperties(final Resource resource, final String filename) throws IOException {
<span class="fc" id="L650">		final Properties props = this.newProperties();</span>
<span class="fc" id="L651">		try (InputStream is = resource.getInputStream()) {</span>
			// RC-
			// String resourceFilename = resource.getFilename();
			// if (resourceFilename != null &amp;&amp; resourceFilename.endsWith(ExtendedMessageSource.XML_SUFFIX)) {
			//     if (this.logger.isDebugEnabled()) {
			//         this.logger.debug(&quot;Loading properties [&quot; + resource.getFilename() + &quot;]&quot;);
			//     }
			//     this.propertiesPersister.loadFromXml(props, is);
			// } else
			// RC-
			// RC+
<span class="fc" id="L662">			String encoding = null;</span>

<span class="pc bpc" id="L664" title="1 of 2 branches missed.">			if (this.fileEncodings != null) {</span>
<span class="nc" id="L665">				encoding = this.fileEncodings.getProperty(filename);</span>
			}
<span class="pc bpc" id="L667" title="1 of 2 branches missed.">			if (encoding == null) {</span>
<span class="fc" id="L668">				encoding = this.getDefaultEncoding();</span>
			}
<span class="pc bpc" id="L670" title="1 of 2 branches missed.">			if (encoding != null) {</span>
<span class="pc bpc" id="L671" title="1 of 2 branches missed.">				if (this.logger.isDebugEnabled()) {</span>
<span class="nc" id="L672">					this.logger.debug(&quot;Loading properties [&quot; + resource.getFilename() + &quot;] with encoding '&quot; + encoding + &quot;'&quot;);</span>
				}
<span class="fc" id="L674">				this.propertiesPersister.load(props, new InputStreamReader(is, encoding));</span>
<span class="fc" id="L675">			} else {</span>
<span class="nc bnc" id="L676" title="All 2 branches missed.">				if (this.logger.isDebugEnabled()) {</span>
<span class="nc" id="L677">					this.logger.debug(&quot;Loading properties [&quot; + resource.getFilename() + &quot;]&quot;);</span>
				}
<span class="nc" id="L679">				this.propertiesPersister.load(props, is);</span>
			}
			// RC+

<span class="fc" id="L683">			return props;</span>
		}
	}

	/**
	 * Template method for creating a plain new {@link Properties} instance.
	 * The default implementation simply calls {@link Properties#Properties()}.
	 * &lt;p&gt;
	 * Allows for returning a custom {@link Properties} extension in subclasses.
	 * Overriding methods should just instantiate a custom {@link Properties} subclass,
	 * with no further initialization or population to be performed at that point.
	 *
	 * @return a plain Properties instance
	 * @since 4.2
	 */
	protected Properties newProperties() {
<span class="fc" id="L699">		return new Properties();</span>
	}

	/**
	 * Clear the resource bundle cache.
	 * Subsequent resolve calls will lead to reloading of the properties files.
	 */
	public void clearCache() {
<span class="nc" id="L707">		this.logger.debug(&quot;Clearing entire resource bundle cache&quot;);</span>
<span class="nc" id="L708">		this.cachedProperties.clear();</span>
<span class="nc" id="L709">		this.cachedMergedProperties.clear();</span>
<span class="nc" id="L710">	}</span>

	/**
	 * Clear the resource bundle caches of this MessageSource and all its ancestors.
	 *
	 * @see #clearCache
	 */
	public void clearCacheIncludingAncestors() {
<span class="nc" id="L718">		this.clearCache();</span>
		// RC-
		// if (this.getParentMessageSource() instanceof ReloadableResourceBundleMessageSource) {
		// 	((ReloadableResourceBundleMessageSource) this.getParentMessageSource()).clearCacheIncludingAncestors();
		// }
		// RC-
		// RC+
		MessageSource parent;
		final ReloadableResourceBundleMessageSource reloadableParent;

<span class="nc" id="L728">		parent = this.getParentMessageSource();</span>
<span class="nc bnc" id="L729" title="All 2 branches missed.">		if (parent instanceof ReloadableResourceBundleMessageSource) {</span>
<span class="nc" id="L730">			reloadableParent = (ReloadableResourceBundleMessageSource) (this.getParentMessageSource());</span>
			// INFO: SonarLint makes a mistake here.  reloadableParent is not nullable here because
			// INFO+ parent instanceof ReloadableResourceBundleMessageSource returns false if parent is null.
<span class="nc bnc" id="L733" title="All 4 branches missed.">			assert reloadableParent != null; </span>
<span class="nc" id="L734">			reloadableParent.clearCacheIncludingAncestors();</span>
		}

<span class="nc" id="L737">	}</span>

	@Override
	public String toString() {
<span class="fc" id="L741">		return this.getClass().getName() + &quot;: basenames=&quot; + this.getBasenameSet();</span>
	}


	/**
	 * PropertiesHolder for caching.
	 * Stores the last-modified timestamp of the source file for efficient
	 * change detection, and the timestamp of the last refresh attempt
	 * (updated every time the cache entry gets re-validated).
	 */
	protected class PropertiesHolder {

		@Nullable
		protected final Properties											properties;

		protected final long												fileTimestamp;

<span class="fc" id="L758">		protected volatile long												refreshTimestamp		= -2;</span>

<span class="fc" id="L760">		protected final ReentrantLock										refreshLock				= new ReentrantLock();</span>

		/** Cache to hold already generated MessageFormats per message code. */
<span class="fc" id="L763">		protected final ConcurrentMap&lt;String, Map&lt;Locale, MessageFormat&gt;&gt;	cachedMessageFormats	= new ConcurrentHashMap&lt;&gt;();</span>


<span class="fc" id="L766">		public PropertiesHolder() {</span>
<span class="fc" id="L767">			this.properties = null;</span>
<span class="fc" id="L768">			this.fileTimestamp = -1;</span>
<span class="fc" id="L769">		}</span>

<span class="fc" id="L771">		public PropertiesHolder(final Properties properties, final long fileTimestamp) {</span>
<span class="fc" id="L772">			this.properties = properties;</span>
<span class="fc" id="L773">			this.fileTimestamp = fileTimestamp;</span>
<span class="fc" id="L774">		}</span>

		@Nullable
		public Properties getProperties() {
<span class="fc" id="L778">			return this.properties;</span>
		}

		public long getFileTimestamp() {
<span class="fc" id="L782">			return this.fileTimestamp;</span>
		}

		public void setRefreshTimestamp(final long refreshTimestamp) {
<span class="fc" id="L786">			this.refreshTimestamp = refreshTimestamp;</span>
<span class="fc" id="L787">		}</span>

		public long getRefreshTimestamp() {
<span class="fc" id="L790">			return this.refreshTimestamp;</span>
		}

		@Nullable
		public String getProperty(final String code) {
<span class="pc bpc" id="L795" title="1 of 2 branches missed.">			if (this.properties == null) {</span>
<span class="nc" id="L796">				return null;</span>
			}
<span class="fc" id="L798">			return this.properties.getProperty(code);</span>
		}

		@Nullable
		public MessageFormat getMessageFormat(final String code, final Locale locale) {
<span class="pc bpc" id="L803" title="1 of 2 branches missed.">			if (this.properties == null) {</span>
<span class="nc" id="L804">				return null;</span>
			}
<span class="fc" id="L806">			Map&lt;Locale, MessageFormat&gt; localeMap = this.cachedMessageFormats.get(code);</span>
<span class="fc bfc" id="L807" title="All 2 branches covered.">			if (localeMap != null) {</span>
<span class="fc" id="L808">				final MessageFormat result = localeMap.get(locale);</span>
<span class="pc bpc" id="L809" title="1 of 2 branches missed.">				if (result != null) {</span>
<span class="fc" id="L810">					return result;</span>
				}
			}
<span class="fc" id="L813">			final String msg = this.properties.getProperty(code);</span>
<span class="fc bfc" id="L814" title="All 2 branches covered.">			if (msg != null) {</span>
<span class="pc bpc" id="L815" title="1 of 2 branches missed.">				if (localeMap == null) {</span>
<span class="fc" id="L816">					localeMap = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L817">					final Map&lt;Locale, MessageFormat&gt; existing = this.cachedMessageFormats.putIfAbsent(code, localeMap);</span>
<span class="pc bpc" id="L818" title="1 of 2 branches missed.">					if (existing != null) {</span>
<span class="nc" id="L819">						localeMap = existing;</span>
					}
				}
<span class="fc" id="L822">				final MessageFormat result = ExtendedMessageSource.this.createMessageFormat(msg, locale);</span>
<span class="fc" id="L823">				localeMap.put(locale, result);</span>
<span class="fc" id="L824">				return result;</span>
			}
<span class="fc" id="L826">			return null;</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span>Acme-Planner (Run) (2 Jun 2021 12:07:42)</div></body></html>