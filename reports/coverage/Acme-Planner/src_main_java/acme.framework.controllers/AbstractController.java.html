<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../jacoco-resources/report.gif" type="image/gif"/><title>AbstractController.java</title><link rel="stylesheet" href="../../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">Acme-Planner (Run) (2 Jun 2021 12:07:42)</a> &gt; <a href="../../index.html" class="el_group">Acme-Planner</a> &gt; <a href="../index.html" class="el_bundle">src/main/java</a> &gt; <a href="index.source.html" class="el_package">acme.framework.controllers</a> &gt; <span class="el_source">AbstractController.java</span></div><h1>AbstractController.java</h1><pre class="source lang-java linenums">/*
 * AbstractController.java
 *
 * Copyright (C) 2012-2021 Rafael Corchuelo.
 *
 * In keeping with the traditional purpose of furthering education and research, it is
 * the policy of the copyright owner to permit non-commercial use and redistribution of
 * this software. It has been tested carefully, but it is not guaranteed for any particular
 * purposes. The copyright owner does not offer any warranties or representations, nor do
 * they accept any liabilities with respect to them.
 */

package acme.framework.controllers;

import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.transaction.Transactional;
import javax.transaction.Transactional.TxType;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.GenericTypeResolver;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.transaction.PlatformTransactionManager;
import org.springframework.transaction.TransactionDefinition;
import org.springframework.transaction.TransactionStatus;
import org.springframework.transaction.support.DefaultTransactionDefinition;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import com.fasterxml.jackson.databind.PropertyNamingStrategy;

import acme.components.CustomCommand;
import acme.framework.components.BasicCommand;
import acme.framework.components.Command;
import acme.framework.components.CommandManager;
import acme.framework.components.Errors;
import acme.framework.components.HttpMethod;
import acme.framework.components.Model;
import acme.framework.components.Request;
import acme.framework.components.Response;
import acme.framework.entities.UserRole;
import acme.framework.helpers.Assert;
import acme.framework.helpers.CollectionHelper;
import acme.framework.helpers.CommandHelper;
import acme.framework.helpers.HttpMethodHelper;
import acme.framework.helpers.StringHelper;
import acme.framework.helpers.ValidationHelper;
import acme.framework.services.AbstractService;
import acme.framework.utilities.ServiceWrapper;

@Controller
<span class="pc bpc" id="L62" title="1 of 2 branches missed.">public abstract class AbstractController&lt;R extends UserRole, E&gt; {</span>

	// Internal state ---------------------------------------------------------

	@Autowired
	protected AbstractController&lt;R, E&gt;		self;

	protected Class&lt;R&gt;						roleClazz;
	protected Class&lt;E&gt;						entityClazz;

	protected String						listViewName;
	protected String						formViewName;

	protected CommandManager&lt;R, E&gt;			commandManager;

	// Transaction management ------------------------------------------------.

	@Autowired
	protected PlatformTransactionManager	transactionManager;
	protected TransactionStatus				transactionStatus;


	protected void startTransaction() {
		TransactionDefinition transactionDefinition;

<span class="fc" id="L87">		transactionDefinition = new DefaultTransactionDefinition();</span>
<span class="fc" id="L88">		this.transactionStatus = this.transactionManager.getTransaction(transactionDefinition);</span>
<span class="fc" id="L89">	}</span>

	protected void commitTransaction() {
<span class="pc bpc" id="L92" title="2 of 4 branches missed.">		assert this.isTransactionActive();</span>

<span class="fc" id="L94">		this.transactionManager.commit(this.transactionStatus);</span>
<span class="fc" id="L95">		this.transactionStatus = null;</span>
<span class="fc" id="L96">	}</span>

	protected void rollbackTransaction() {
<span class="pc bpc" id="L99" title="2 of 4 branches missed.">		assert this.isTransactionActive();</span>

<span class="fc" id="L101">		this.transactionManager.rollback(this.transactionStatus);</span>
<span class="fc" id="L102">		this.transactionStatus = null;</span>
<span class="fc" id="L103">	}</span>

	protected boolean isTransactionActive() {
		boolean result;

<span class="pc bpc" id="L108" title="2 of 4 branches missed.">		result = this.transactionStatus != null &amp;&amp; !this.transactionStatus.isCompleted();</span>

<span class="fc" id="L110">		return result;</span>
	}

	// Command Management -----------------------------------------------------

	public void addBasicCommand(final BasicCommand basicCommand, final AbstractService&lt;R, E&gt; listService) {
<span class="pc bpc" id="L116" title="2 of 4 branches missed.">		assert basicCommand != null;</span>
<span class="pc bpc" id="L117" title="2 of 4 branches missed.">		assert !this.commandManager.isRegistered(basicCommand);</span>
<span class="pc bpc" id="L118" title="2 of 4 branches missed.">		assert listService != null;</span>

<span class="fc" id="L120">		this.commandManager.addBasicCommand(basicCommand, listService);</span>
<span class="fc" id="L121">	}</span>

	public void addCustomCommand(final CustomCommand customCommand, final BasicCommand baseCommand, final AbstractService&lt;R, E&gt; service) {
<span class="nc bnc" id="L124" title="All 4 branches missed.">		assert customCommand != null;</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">		assert !this.commandManager.isRegistered(customCommand);</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">		assert service != null;</span>

<span class="nc" id="L128">		this.commandManager.addCustomCommand(customCommand, baseCommand, service);</span>
<span class="nc" id="L129">	}</span>

	// Constructor ------------------------------------------------------------

	@SuppressWarnings(&quot;unchecked&quot;)
<span class="fc" id="L134">	protected AbstractController() {</span>
		Class&lt;?&gt;[] types;
		PropertyNamingStrategy.KebabCaseStrategy translator;
		String roleName, entityName;

<span class="fc" id="L139">		types = GenericTypeResolver.resolveTypeArguments(this.getClass(), AbstractController.class);</span>

<span class="pc bpc" id="L141" title="2 of 4 branches missed.">		if (types == null || types.length != 2) {</span>
<span class="nc" id="L142">			System.err.printf(&quot;I'm sorry, %s cannot be instantiated.%n&quot;, this.getClass().getName());</span>
<span class="nc" id="L143">			System.err.printf(&quot;I can't resolve its generic types.%n&quot;);</span>
<span class="nc" id="L144">			System.exit(1);</span>
		}

<span class="fc" id="L147">		this.roleClazz = (Class&lt;R&gt;) types[0];</span>
<span class="fc" id="L148">		this.entityClazz = (Class&lt;E&gt;) types[1];</span>

<span class="fc" id="L150">		translator = new PropertyNamingStrategy.KebabCaseStrategy();</span>
<span class="fc" id="L151">		roleName = translator.translate(this.roleClazz.getSimpleName());</span>
<span class="fc" id="L152">		entityName = translator.translate(this.entityClazz.getSimpleName());</span>

<span class="fc" id="L154">		this.listViewName = String.format(&quot;%s/%s/list&quot;, roleName, entityName);</span>
<span class="fc" id="L155">		this.formViewName = String.format(&quot;%s/%s/form&quot;, roleName, entityName);</span>

<span class="fc" id="L157">		this.commandManager = new CommandManager&lt;R, E&gt;();</span>
<span class="fc" id="L158">	}</span>

	// Handler ----------------------------------------------------------------

	@RequestMapping(value = &quot;{endpoint}&quot;, method = {
		RequestMethod.GET, RequestMethod.POST
	})
	public ModelAndView handleRequest( //
		@PathVariable(&quot;endpoint&quot;) final String endpoint, //
		@RequestParam final Map&lt;String, Object&gt; model, //
		final HttpServletRequest servletRequest, //
		final HttpServletResponse servletResponse, //
		final Locale locale) {

		ModelAndView result;
		String servletMethod;
		HttpMethod method;
		Command command;
		BasicCommand baseCommand;
		Request&lt;E&gt; request;
		Response&lt;E&gt; response;
		ServiceWrapper&lt;R, E&gt; service;

<span class="fc" id="L181">		result = null;</span>
<span class="fc" id="L182">		request = null;</span>
<span class="fc" id="L183">		response = null;</span>
<span class="fc" id="L184">		service = null;</span>

		try {
			// HINT: let's start a new transaction.

<span class="fc" id="L189">			this.startTransaction();</span>

			// HINT: let's deal with CSRF hacking.

<span class="fc bfc" id="L193" title="All 2 branches covered.">			if (model.containsKey(&quot;_csrf&quot;)) {</span>
				// HINT: Remove it so that a new token is generated automatically
<span class="fc" id="L195">				model.remove(&quot;_csrf&quot;);</span>
			}

			// HINT: let's make sure that the command is available.

<span class="fc" id="L200">			servletMethod = servletRequest.getMethod();</span>
<span class="fc" id="L201">			method = HttpMethodHelper.parse(servletMethod);</span>
<span class="fc" id="L202">			command = CommandHelper.parse(endpoint);</span>
<span class="fc" id="L203">			Assert.state(this.commandManager.isRegistered(command), locale, &quot;default.error.endpoint-unavailable&quot;);</span>
<span class="fc" id="L204">			baseCommand = this.commandManager.getBaseCommand(command);</span>

			// HINT: let's create the request object.

<span class="fc" id="L208">			request = new Request&lt;E&gt;( //</span>
<span class="fc" id="L209">				method, command, baseCommand, //</span>
<span class="fc" id="L210">				model, locale, //</span>
<span class="fc" id="L211">				servletRequest, servletResponse);</span>

			// HINT: let's make sure that the principal has the appropriate role.

<span class="fc" id="L215">			Assert.state(request.getPrincipal().hasRole(this.roleClazz), locale, &quot;default.error.not-authorised&quot;);</span>
<span class="fc" id="L216">			request.getPrincipal().setActiveRole(this.roleClazz);</span>

			// HINT: let's request authorisation from the service.

<span class="fc" id="L220">			service = new ServiceWrapper&lt;R, E&gt;(this.commandManager.getService(command));</span>
<span class="fc" id="L221">			Assert.state(service.authorise(request), locale, &quot;default.error.not-authorised&quot;);</span>

			// HINT: let's dispatch the request building on the HTTP method used.
			// HINT: realise that the dispatcher method is invoked through the 'self' reference to this
			// HINT+ controller because they must be executed within the current transaction.

<span class="pc bpc" id="L227" title="1 of 3 branches missed.">			switch (request.getMethod()) {</span>
			case GET:
<span class="fc" id="L229">				response = this.self.doGet(request, service);</span>
<span class="fc" id="L230">				break;</span>
			case POST:
<span class="fc" id="L232">				response = this.self.doPost(request, service);</span>
<span class="fc" id="L233">				break;</span>
			default:
<span class="nc" id="L235">				Assert.state(false, locale, &quot;default.error.endpoint-unavailable&quot;);</span>
<span class="pc bpc" id="L236" title="1 of 2 branches missed.">				break;</span>
			}
<span class="pc bpc" id="L238" title="1 of 2 branches missed.">			assert response != null;</span>

			// HINT: let's commit or rollback the transaction depending on whether there are errors or not in the response.
			// HINT+ note that the 'onSuccess' and the 'onFailure' methods must be executed in fresh transactions.

<span class="fc bfc" id="L243" title="All 2 branches covered.">			if (!response.hasErrors()) {</span>
<span class="fc" id="L244">				this.commitTransaction();</span>
<span class="fc" id="L245">				this.startTransaction();</span>
<span class="fc" id="L246">				service.onSuccess(request, response);</span>
<span class="fc" id="L247">				this.commitTransaction();</span>
<span class="fc" id="L248">			} else {</span>
<span class="fc" id="L249">				this.rollbackTransaction();</span>
<span class="fc" id="L250">				this.startTransaction();</span>
<span class="fc" id="L251">				service.onFailure(request, response, null);</span>
<span class="fc" id="L252">				this.commitTransaction();</span>
			}

			// HINT: let's build the requested view and let's add some predefined attributes to the model.

<span class="fc" id="L257">			result = this.buildRequestedView(request, response);</span>
<span class="fc" id="L258">			result.addObject(&quot;command&quot;, endpoint);</span>
<span class="fc" id="L259">			result.addObject(&quot;principal&quot;, request.getPrincipal());</span>
<span class="fc" id="L260">		} catch (final Throwable oops) {</span>
			// HINT: if a throwable is caught, then the current transaction must be rollbacked, if any,
			// HINT: the service must execute the 'onFailure' method, and the panic view must be returned.

<span class="pc bpc" id="L264" title="1 of 2 branches missed.">			if (this.isTransactionActive()) {</span>
<span class="fc" id="L265">				this.rollbackTransaction();</span>
			}
<span class="fc bfc" id="L267" title="All 2 branches covered.">			if (service != null) {</span>
<span class="fc" id="L268">				this.startTransaction();</span>
<span class="fc" id="L269">				service.onFailure(request, response, oops);</span>
<span class="fc" id="L270">				this.commitTransaction();</span>
			}
<span class="fc" id="L272">			result = this.buildPanicView(request, response, oops);</span>
		}

		// HINT: must always return a 'ModelAndView' object, be it the user-defined one or a panic one.

<span class="pc bpc" id="L277" title="2 of 4 branches missed.">		assert result != null;</span>

<span class="fc" id="L279">		return result;</span>
	}

	@Transactional(TxType.MANDATORY)
	public Response&lt;E&gt; doGet(final Request&lt;E&gt; request, final ServiceWrapper&lt;R, E&gt; service) {
<span class="pc bpc" id="L284" title="2 of 4 branches missed.">		assert request != null;</span>
<span class="pc bpc" id="L285" title="2 of 4 branches missed.">		assert service != null;</span>

		Response&lt;E&gt; result;
		Collection&lt;E&gt; list;
		E entity;
		String view;
		Model model;
		Errors errors;

<span class="fc" id="L294">		view = null;</span>
<span class="fc" id="L295">		model = null;</span>
<span class="fc" id="L296">		errors = null;</span>

		// HINT: let's dispatch according to the semantics of the base command.

<span class="pc bpc" id="L300" title="1 of 4 branches missed.">		switch (request.getBaseCommand()) {</span>
		case LIST:
			// HINT: a LIST requests using the 'GET' method is served as follows:
			// HINT+ a) find the many objects to be shown; b) unbind the list into a fresh model.
			// HINT+ Note that no errors are expected, but exceptions might be thrown.
<span class="fc" id="L305">			list = service.findMany(request);</span>
<span class="fc" id="L306">			view = this.listViewName;</span>
<span class="fc" id="L307">			model = new Model();</span>
<span class="fc" id="L308">			this.unbind(request, list, model, service);</span>
<span class="fc" id="L309">			errors = new Errors();</span>
<span class="fc" id="L310">			break;</span>
		case SHOW:
		case UPDATE:
		case DELETE:
			// HINT: a SHOW, UPDATE, or DELETE requests using the 'GET' method are served as follows:
			// HINT+ a) find the object to be shown, updated, or deleted using the data in the request;
			// HINT+ b) unbind that object into a fresh model.  Note that no errors are expected, but
			// HINT+ exceptions might be thrown.
<span class="fc" id="L318">			entity = service.findOne(request);</span>
<span class="fc" id="L319">			view = this.formViewName;</span>
<span class="fc" id="L320">			model = new Model();</span>
<span class="fc" id="L321">			service.unbind(request, entity, model);</span>
<span class="fc" id="L322">			errors = new Errors();</span>
<span class="fc" id="L323">			break;</span>
		case PERFORM:
		case CREATE:
			// HINT: a PERFORM/CREATE request using the 'GET' method are served as follows:
			// HINT+ a) instantiate the object to create using the data in the request; b) unbind that
			// HINT+ object to a fresh model.  Note that no errors are expected, but exceptions might be thrown.
<span class="fc" id="L329">			entity = service.instantiate(request);</span>
<span class="fc" id="L330">			view = this.formViewName;</span>
<span class="fc" id="L331">			model = new Model();</span>
<span class="fc" id="L332">			service.unbind(request, entity, model);</span>
<span class="fc" id="L333">			errors = new Errors();</span>
<span class="fc" id="L334">			break;</span>
		default:
<span class="nc" id="L336">			Assert.state(false, request.getLocale(), &quot;default.error.endpoint-unavailable&quot;);</span>
<span class="pc bpc" id="L337" title="1 of 2 branches missed.">			break;</span>
		}

		// HINT: unless an exception is thrown, the previous statements must produce a view name, a model, and an errors object.

<span class="pc bpc" id="L342" title="1 of 2 branches missed.">		assert !StringHelper.isBlank(view);</span>
<span class="pc bpc" id="L343" title="2 of 4 branches missed.">		assert model != null;</span>
<span class="pc bpc" id="L344" title="2 of 4 branches missed.">		assert errors != null;</span>

<span class="fc" id="L346">		result = new Response&lt;E&gt;(view, model, errors);</span>

<span class="fc" id="L348">		return result;</span>
	}

	@Transactional(TxType.MANDATORY)
	public Response&lt;E&gt; doPost(final Request&lt;E&gt; request, final ServiceWrapper&lt;R, E&gt; service) throws Exception {
<span class="pc bpc" id="L353" title="2 of 4 branches missed.">		assert request != null;</span>
<span class="pc bpc" id="L354" title="2 of 4 branches missed.">		assert service != null;</span>

		Response&lt;E&gt; result;
		E entity;
		String view;
		Model model;
		Errors errors;

		// HINT: the first step to handle a POST request fetches the entity to be handled.

<span class="fc" id="L364">		entity = null;</span>
<span class="pc bpc" id="L365" title="1 of 3 branches missed.">		switch (request.getBaseCommand()) {</span>
		case PERFORM:
		case CREATE:
			// HINT: a PERFORM or CREATE request involves instantiating the appropriate entity from the
			// HINT+ request.
<span class="fc" id="L370">			entity = service.instantiate(request);</span>
<span class="fc" id="L371">			break;</span>
		case UPDATE:
		case DELETE:
			// HINT: an UPDATE or a DELETE request involves finding the entity to be updated or deleted.
<span class="fc" id="L375">			entity = service.findOne(request);</span>
<span class="fc" id="L376">			break;</span>
		default:
<span class="nc" id="L378">			Assert.state(false, request.getLocale(), &quot;default.error.endpoint-unavailable&quot;);</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">			break;</span>
		}
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">		assert entity != null;</span>

		// HINT: the second step cares of performing the command on the entity fetched by the previous step.

<span class="fc" id="L385">		model = new Model();</span>
<span class="fc" id="L386">		errors = new Errors();</span>
<span class="pc bpc" id="L387" title="2 of 5 branches missed.">		switch (request.getBaseCommand()) {</span>
		case PERFORM:
			// HINT: dealing with a PERFORM request involves the following steps: a) binding the request onto
			// HINT+ the entity instantiated by the previous step; b) performing constraint validation on it;
			// HINT+ c) performing user-defined validation; d) invoking the service to perform the query if
			// HINT+ if there are not any errors; and e) unbinding the result to the output model if there
			// HINT+ are not any errors.
<span class="nc" id="L394">			service.bind(request, entity, errors);</span>
<span class="nc" id="L395">			ValidationHelper.validate(request, entity, errors);</span>
<span class="nc" id="L396">			service.validate(request, entity, errors);</span>
<span class="nc bnc" id="L397" title="All 2 branches missed.">			if (!errors.hasErrors()) {</span>
<span class="nc" id="L398">				service.perform(request, entity, errors);</span>
			}
<span class="nc bnc" id="L400" title="All 2 branches missed.">			if (!errors.hasErrors()) {</span>
<span class="nc" id="L401">				service.unbind(request, entity, model);</span>
			}
<span class="nc" id="L403">			break;</span>
		case CREATE:
			// HINT: dealing with a CREATE request involves the following steps: a) binding the request onto
			// HINT+ the entity instantiated by the previous step; b) performing constraint validation on it;
			// HINT+ c) performing user-defined validation; d) if there are not any errors, then invoking the
			// HINT+ service to create the entity.
<span class="fc" id="L409">			service.bind(request, entity, errors);</span>
<span class="fc" id="L410">			ValidationHelper.validate(request, entity, errors);</span>
<span class="fc" id="L411">			service.validate(request, entity, errors);</span>
<span class="fc bfc" id="L412" title="All 2 branches covered.">			if (!errors.hasErrors()) {</span>
<span class="fc" id="L413">				service.create(request, entity);</span>
			}
<span class="fc" id="L415">			break;</span>
		case UPDATE:
			// HINT: dealing with an UPDATE request involves the following steps: a) binding the request onto
			// HINT+ the entity fetched by the previous step; b) performing constraint validation on it;
			// HINT+ c) performing user-defined validation; d) if there are not any errors, then invoking the
			// HINT+ service to update the entity.
<span class="fc" id="L421">			service.bind(request, entity, errors);</span>
<span class="fc" id="L422">			ValidationHelper.validate(request, entity, errors);</span>
<span class="fc" id="L423">			service.validate(request, entity, errors);</span>
<span class="fc bfc" id="L424" title="All 2 branches covered.">			if (!errors.hasErrors()) {</span>
<span class="fc" id="L425">				service.update(request, entity);</span>
			}
<span class="fc" id="L427">			break;</span>
		case DELETE:
			// HINT: dealing with a DELETE request involves validating that the entity can be deleted
			// HINT+ and then invoking the service to delete the entity.
<span class="fc" id="L431">			service.validate(request, entity, errors);</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">			if (!errors.hasErrors()) {</span>
<span class="fc" id="L433">				service.delete(request, entity);</span>
			}
<span class="fc" id="L435">			break;</span>
		default:
<span class="nc" id="L437">			Assert.state(false, request.getLocale(), &quot;default.error.endpoint-unavailable&quot;);</span>
<span class="pc bpc" id="L438" title="1 of 2 branches missed.">			break;</span>
		}

<span class="pc bpc" id="L441" title="1 of 2 branches missed.">		assert model != null;</span>
<span class="pc bpc" id="L442" title="2 of 4 branches missed.">		assert errors != null;</span>

<span class="pc bpc" id="L444" title="1 of 2 branches missed.">		if (request.getBaseCommand().equals(BasicCommand.PERFORM)) {</span>
			// HINT: if we're dealing with a PERFORM request, then we return the same view and
			// HINT+ reset the model if there are any errors.
<span class="nc" id="L447">			view = this.formViewName;</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">			if (errors.hasErrors()) {</span>
<span class="nc" id="L449">				model.append(request.getModel());</span>
			}
<span class="nc" id="L451">		} else {</span>
<span class="pc bpc" id="L452" title="1 of 4 branches missed.">			if (!errors.hasErrors() &amp;&amp; !request.getBaseCommand().equals(BasicCommand.PERFORM)) {</span>
				// HINT: if there aren't any errors, then we must redirect to the referrer view, which cares of
				// HINT+ returning to the appropriate listing or /master/welcome.
<span class="fc" id="L455">				view = &quot;redirect:/master/referrer&quot;;</span>
<span class="fc" id="L456">			} else {</span>
				// HINT: if there are some errors, then we must redirect to the same view.  The model
				// HINT+ is the same, so that the user may make changes and submit the form again.
<span class="fc" id="L459">				view = this.formViewName;</span>
<span class="fc" id="L460">				model.append(request.getModel());</span>
			}
		}

		// HINT: unless an exception is thrown, the previous statements must produce a view name, a model,
		// HINT+ and an errors object.

<span class="pc bpc" id="L467" title="2 of 4 branches missed.">		assert !StringHelper.isBlank(view);</span>
<span class="pc bpc" id="L468" title="2 of 4 branches missed.">		assert model != null;</span>
<span class="pc bpc" id="L469" title="2 of 4 branches missed.">		assert errors != null;</span>

<span class="fc" id="L471">		result = new Response&lt;E&gt;(view, model, errors);</span>

<span class="fc" id="L473">		return result;</span>
	}

	// Internal methods -------------------------------------------------------

	protected void unbind(final Request&lt;E&gt; request, final Collection&lt;E&gt; list, final Model model, final ServiceWrapper&lt;R, E&gt; service) {
<span class="pc bpc" id="L479" title="2 of 4 branches missed.">		assert request != null;</span>
<span class="pc bpc" id="L480" title="2 of 4 branches missed.">		assert !CollectionHelper.someNull(list);</span>
<span class="pc bpc" id="L481" title="2 of 4 branches missed.">		assert service != null;</span>

		Model entityModel;

<span class="fc bfc" id="L485" title="All 2 branches covered.">		for (final E entity : list) {</span>
<span class="fc" id="L486">			entityModel = new Model();</span>
<span class="fc" id="L487">			service.unbind(request, entity, entityModel);</span>
<span class="fc" id="L488">			model.append(entityModel);</span>
		}
<span class="fc" id="L490">	}</span>

	protected ModelAndView buildRequestedView(final Request&lt;E&gt; request, final Response&lt;E&gt; response) {
		ModelAndView result;
		String name;
		int size;
		Map&lt;String, Object&gt; model;
		String key, fullKey;
		Object value;
		List&lt;String&gt; messages;
		String text;

<span class="fc" id="L502">		result = new ModelAndView();</span>
<span class="fc" id="L503">		result.setStatus(HttpStatus.OK);</span>
<span class="fc" id="L504">		result.setViewName(response.getView());</span>

<span class="fc" id="L506">		size = response.getModel().size();</span>
<span class="fc" id="L507">		result.addObject(&quot;model$size&quot;, size);</span>
<span class="fc bfc" id="L508" title="All 2 branches covered.">		for (int index = 0; index &lt; size; index++) {</span>
<span class="fc" id="L509">			model = response.getModel().get(index);</span>
<span class="fc bfc" id="L510" title="All 2 branches covered.">			for (final Entry&lt;String, Object&gt; entry : model.entrySet()) {</span>
<span class="fc" id="L511">				key = entry.getKey();</span>
<span class="fc" id="L512">				value = entry.getValue();</span>

<span class="fc bfc" id="L514" title="All 2 branches covered.">				if (size == 1) {</span>
<span class="fc" id="L515">					fullKey = key;</span>
<span class="fc" id="L516">				} else {</span>
<span class="fc" id="L517">					fullKey = String.format(&quot;%s[%d]&quot;, key, index);</span>
				}

<span class="fc" id="L520">				result.addObject(fullKey, value);</span>
			}
		}

		// INFO: errors are not bound if the model is a list, which avoids editing lists.
<span class="fc bfc" id="L525" title="All 2 branches covered.">		if (response.hasErrors()) {</span>
<span class="fc bfc" id="L526" title="All 2 branches covered.">			for (final Entry&lt;String, List&lt;String&gt;&gt; entry : response.getErrors()) {</span>
<span class="fc" id="L527">				name = String.format(&quot;%s$error&quot;, entry.getKey());</span>
<span class="fc" id="L528">				messages = entry.getValue();</span>
<span class="fc" id="L529">				text = StringHelper.toString(messages, &quot;. &quot;, &quot;.&quot;);</span>
<span class="fc" id="L530">				result.addObject(name, text);</span>
			}
		}

<span class="fc" id="L534">		return result;</span>
	}

	protected ModelAndView buildPanicView(final Request&lt;E&gt; request, final Response&lt;E&gt; response, final Throwable oops) {
		ModelAndView result;

<span class="fc" id="L540">		result = new ModelAndView();</span>
<span class="fc" id="L541">		result.setStatus(HttpStatus.INTERNAL_SERVER_ERROR);</span>
<span class="fc" id="L542">		result.setViewName(&quot;master/panic&quot;);</span>
<span class="fc" id="L543">		result.addObject(&quot;oops&quot;, oops);</span>

<span class="fc" id="L545">		return result;</span>
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.6.202009150832</span>Acme-Planner (Run) (2 Jun 2021 12:07:42)</div></body></html>